// Generated by a tool, do not change manually
// Tool: GenerateLibrary.ps1
// Generated Date: 

using Microsoft.Extensions.Logging;

namespace CommonLoggingLibrary.EventIds
{
  /// <summary>
  /// Positive, normal run, expected, operational events like calling an external service, running diagnostics -  No intervention required by anyone
  /// </summary>
  public static class OperationalInformation
  {
    /// <summary>
    /// 201 The application is connecting to the external system.  Used in the raising of Event ID <see cref="Constants.EXTERNAL_CONNECTINGTO">201</see>.  To raise this Event, use method <see cref="External.ConnectingTo"/>
    /// </summary>
    /// <remarks>
    /// <para>Don&#39;t confuse Connecting vs Calling.  Calling is calling the external system&#39;s method/function, Connecting is typical of target systems that needs to be connected before being used/called, systems that have a certain keep-alive mechanism, authentication or two-way communication, like Sql Connection and SignalR</para>
    /// </remarks>
    public static EventId External_ConnectingTo => new(Constants.EXTERNAL_CONNECTINGTO, nameof(External.ExternalLoggingExtensions.External_ConnectingTo));
    /// <summary>
    /// 202 A successful connection has been created with the target system.  Used in the raising of Event ID <see cref="Constants.EXTERNAL_CONNECTEDTO">202</see>.  To raise this Event, use method <see cref="External.ConnectedTo"/>
    /// </summary>
    public static EventId External_ConnectedTo => new(Constants.EXTERNAL_CONNECTEDTO, nameof(External.ExternalLoggingExtensions.External_ConnectedTo));
    /// <summary>
    /// 203 Calling the external target system&#39;s method/function  Used in the raising of Event ID <see cref="Constants.EXTERNAL_CALLING">203</see>.  To raise this Event, use method <see cref="External.Calling"/>
    /// </summary>
    public static EventId External_Calling => new(Constants.EXTERNAL_CALLING, nameof(External.ExternalLoggingExtensions.External_Calling));
    /// <summary>
    /// 204 Indicates that, according to self diagnostics and the best of knowledge, the application is running normally.  Used in the raising of Event ID <see cref="Constants.APPLICATION_INNORMALMODE">204</see>.  To raise this Event, use method <see cref="Application.InNormalMode"/>
    /// </summary>
    public static EventId Application_InNormalMode => new(Constants.APPLICATION_INNORMALMODE, nameof(Application.ApplicationLoggingExtensions.Application_InNormalMode));
    /// <summary>
    /// 205 Just like the HTTP verb HEAD, indicates a &quot;Ping&quot; method has been issued and the application is responding with a &quot;Pong&quot; indicating it&#39;s alive, kicking and ready to roll.  Used in the raising of Event ID <see cref="Constants.DIAGNOSTICS_PONG">205</see>.  To raise this Event, use method <see cref="Diagnostics.Pong"/>
    /// </summary>
    public static EventId Diagnostics_Pong => new(Constants.DIAGNOSTICS_PONG, nameof(Diagnostics.DiagnosticsLoggingExtensions.Diagnostics_Pong));
    /// <summary>
    /// 206 Like the HTTP verb TRACE or a network Trace method, this method indicates a &quot;Trace&quot; method has been issued, and might be about to call target systems  Used in the raising of Event ID <see cref="Constants.DIAGNOSTICS_TRACESTARTED">206</see>.  To raise this Event, use method <see cref="Diagnostics.TraceStarted"/>
    /// </summary>
    public static EventId Diagnostics_TraceStarted => new(Constants.DIAGNOSTICS_TRACESTARTED, nameof(Diagnostics.DiagnosticsLoggingExtensions.Diagnostics_TraceStarted));
    /// <summary>
    /// 207 Marks the end of a trace, that the app is returning the trace results.  Used in the raising of Event ID <see cref="Constants.DIAGNOSTICS_TRACEFINISHED">207</see>.  To raise this Event, use method <see cref="Diagnostics.TraceFinished"/>
    /// </summary>
    public static EventId Diagnostics_TraceFinished => new(Constants.DIAGNOSTICS_TRACEFINISHED, nameof(Diagnostics.DiagnosticsLoggingExtensions.Diagnostics_TraceFinished));
    /// <summary>
    /// 208 Just like Data in Star Trek, or your car when you turn the key, these are quick tests.  This marks the start of the self-diagnostics.  Used in the raising of Event ID <see cref="Constants.DIAGNOSTICS_SELFCHECKSTARTED">208</see>.  To raise this Event, use method <see cref="Diagnostics.SelfCheckStarted"/>
    /// </summary>
    /// <remarks>
    /// <para>Not to be confused with Health Check.  A health check is way more thorough and a long process than a self-check.</para>
    /// </remarks>
    public static EventId Diagnostics_SelfCheckStarted => new(Constants.DIAGNOSTICS_SELFCHECKSTARTED, nameof(Diagnostics.DiagnosticsLoggingExtensions.Diagnostics_SelfCheckStarted));
    /// <summary>
    /// 209 All systems are go.  Used in the raising of Event ID <see cref="Constants.DIAGNOSTICS_SELFCHECKVALID">209</see>.  To raise this Event, use method <see cref="Diagnostics.SelfCheckValid"/>
    /// </summary>
    public static EventId Diagnostics_SelfCheckValid => new(Constants.DIAGNOSTICS_SELFCHECKVALID, nameof(Diagnostics.DiagnosticsLoggingExtensions.Diagnostics_SelfCheckValid));
    /// <summary>
    /// 210 Health check is much more complex and thorough than a self-diagnostics.  Used in the raising of Event ID <see cref="Constants.DIAGNOSTICS_HEALTHCHECKSTARTED">210</see>.  To raise this Event, use method <see cref="Diagnostics.HealthCheckStarted"/>
    /// </summary>
    /// <remarks>
    /// <para>During a health check, a battery of tests are typically performed, validating that it&#39;s capable of calling, modifying, deleting, interacting with every part of the system, including external systems.</para>
    /// <para>The goal of a health check is to make sure it catches actions it can&#39;t do before the end-user figures it out, good UX.</para>
    /// <para>A great application will have a plan B in the event it finds it can&#39;t do certain actions, inform the IT/Admins and update the UI accordingly so the user aware of the situation but that they&#39;re in good hands and that they don&#39;t have to worry, things will be alright.</para>
    /// <para>There&#39;s a good chance that this when the application is put in {see 401} degraded mode.</para>
    /// </remarks>
    public static EventId Diagnostics_HealthCheckStarted => new(Constants.DIAGNOSTICS_HEALTHCHECKSTARTED, nameof(Diagnostics.DiagnosticsLoggingExtensions.Diagnostics_HealthCheckStarted));
    /// <summary>
    /// 211 All tests have returned and the app got a passing grade.  Used in the raising of Event ID <see cref="Constants.DIAGNOSTICS_HEALTHCHECKISHEALTHY">211</see>.  To raise this Event, use method <see cref="Diagnostics.HealthCheckIsHealthy"/>
    /// </summary>
    public static EventId Diagnostics_HealthCheckIsHealthy => new(Constants.DIAGNOSTICS_HEALTHCHECKISHEALTHY, nameof(Diagnostics.DiagnosticsLoggingExtensions.Diagnostics_HealthCheckIsHealthy));
    /// <summary>
    /// 212 The Dependency Framework has loaded what was requested, but are they the right version?  Used in the raising of Event ID <see cref="Constants.DEPENDENCY_VALIDATINGVERSION">212</see>.  To raise this Event, use method <see cref="Dependency.ValidatingVersion"/>
    /// </summary>
    public static EventId Dependency_ValidatingVersion => new(Constants.DEPENDENCY_VALIDATINGVERSION, nameof(Dependency.DependencyLoggingExtensions.Dependency_ValidatingVersion));
    /// <summary>
    /// 213 The version of the loaded resource matches the expected version.  Used in the raising of Event ID <see cref="Constants.DEPENDENCY_VERSIONMATCHESEXPECTED">213</see>.  To raise this Event, use method <see cref="Dependency.VersionMatchesExpected"/>
    /// </summary>
    public static EventId Dependency_VersionMatchesExpected => new(Constants.DEPENDENCY_VERSIONMATCHESEXPECTED, nameof(Dependency.DependencyLoggingExtensions.Dependency_VersionMatchesExpected));
    /// <summary>
    /// 418 There is coffee all over the world. Increasingly, in a world in which computing is ubiquitous, the computists want to make coffee. Coffee brewing is an art, but the distributed intelligence of the web-connected world transcends art.  Thus, there is a strong, dark, rich requirement for a protocol designed espressoly for the brewing of coffee. Coffee is brewed using coffee pots.  Networked coffee pots require a control protocol if they are to be controlled  Used in the raising of Event ID <see cref="Constants.DIAGNOSTICS_IMATEAPOT">418</see>.  To raise this Event, use method <see cref="Diagnostics.ImaTeapot"/>
    /// </summary>
    /// <remarks>
    /// <para>Increasingly, home and consumer devices are being connected to the Internet. Early networking experiments demonstrated vending devices connected to the Internet for status monitoring [COKE]. One of the first remotely _operated_ machine to be hooked up to the Internet, the Internet Toaster, (controlled via SNMP) was debuted in 1990[RFC2235].</para>
    /// <para>The demand for ubiquitous appliance connectivity that is causing the consumption of the IPv4 address space. Consumers want remote control of devices such as coffee pots so that they may wake up to freshly brewed coffee, or cause coffee to be prepared at a precise time after the completion of dinner preparations.</para>
    /// </remarks>
    public static EventId Diagnostics_ImaTeapot => new(Constants.DIAGNOSTICS_IMATEAPOT, nameof(Diagnostics.DiagnosticsLoggingExtensions.Diagnostics_ImaTeapot));
  }
}

